# Task: Implement the "Structural Gravity" Ranking Suite

## 1. Objective
Implement a high-performance, structurally aware ranking system for `cs`. This system leverages `scc`'s byte-slice state map and complexity metrics to prioritize meaningful logic over documentation and data noise.

## 2. Multi-Stage Ranking Logic
The final score for a file result should be calculated by applying the following four filters in order:

### A. Layered Weighting (State Masking)
Use the `scc` `StateMap` (`[]byte`) to weight matches based on where they occur.
* **StateCode (0):** Multiplier `1.0`
* **StateComment (1):** Multiplier `0.2` (Default)
* **StateString (2):** Multiplier `0.5` (Default)

### B. Complexity Gravity (The "Rise")
Apply a logarithmic boost based on total cyclomatic complexity to surface logic-heavy files.
* **Formula:** `Score *= (1.0 + (ln(1 + Complexity) * GravityStrength))`
* **Intents:**
    * `brain`: Strength `2.5`
    * `logic`: Strength `1.5`
    * `default`: Strength `1.0`
    * `low`: Strength `0.2`



### C. Signal-to-Noise (The "Sink")
Penalize "noisy" files (massive files with no logic) like JSON, minified JS, or SQL dumps.
* **Formula:** `SignalRatio = (Complexity + 1) / log10(max(10, FileBytes))`
* **Formula:** `Score *= min(1.0, SignalRatio * NoiseSensitivity)`
* **Intents:** `silence` (0.1), `quiet` (0.5), `default` (1.0), `loud` (2.0), `raw` (100.0).



### D. Language-Specific Stopwords
Dampen common syntactic keywords based on the file's language.
* **Penalty:** `0.1` multiplier to the word's weight.
* **Safeguard:** If the **entire query** consists of stopwords for that language, the penalty is **disabled** (`1.0`) to allow pattern searching.

---

## 3. Stopword Table Reference
Define the following sets for common languages. During planning we will need to define more of these for the most common languages. We can match this up against the known scc database to ensure it works.

| Language | Syntactic Stopwords (Noise) |
| :--- | :--- |
| **Go** | `if`, `err`, `nil`, `func`, `interface`, `type`, `return`, `package` |
| **Rust** | `pub`, `fn`, `let`, `mut`, `match`, `use`, `impl`, `crate` |
| **Java** | `public`, `private`, `static`, `void`, `class`, `import`, `extends` |
| **Python** | `def`, `self`, `import`, `from`, `as`, `None`, `return` |
| **C/C++** | `include`, `void`, `int`, `char`, `struct`, `define`, `ifndef` |

---

## 4. Implementation Requirements for the Agent

1. **Refactor `rankResultsStructural`**:
    * Calculate weighted term frequency using the state weights from the `scc` byte slice.
    * Apply the **Stopword Penalty** ($0.1$) if the query contains a mix of "content" and "stopwords."
    * Ensure that if the query is **Only Stopwords**, no penalty is applied.

2. **Post-Processing Loop**:
    * Apply **Complexity Gravity** using `math.Log1p(float64(complexity))`.
    * Apply the **Signal-to-Noise** penalty. Ensure `FileBytes` is treated as a float and capped at a minimum of `10` for the `log10` calculation.
    * The STN penalty must be clamped at `1.0` (it should never boost a score).

3. **CLI/Config Integration**:
    * Map user-facing strings (`brain`, `silence`, etc.) to the numeric constants defined above.
    * Provide flags for `--logic` and `--noise`.

---

## 5. Mathematical Summary

$$Score = \left( \sum (TF_{weighted} \times IDF \times \Delta_{stopword}) \right) \times \text{Gravity} \times \text{Penalty}_{noise}$$

* **Gravity:** $1 + (\ln(1 + Complexity) \times Strength)$
* **Penalty:** $\min(1.0, \frac{Complexity + 1}{\log_{10}(Bytes)} \times Sensitivity)$