```markdown
# CodeSpelunker MCP Tool — Feature Tasks

## 1. Expose `NOT path:vendor` in MCP Tool Documentation
**Priority: High**

The underlying engine supports `NOT path:vendor` but it is not shown as an example in the MCP tool
description. LLMs constructing queries lean heavily on examples and will reach for `NOT file:vendor`
instead, which only matches on the filename itself rather than the full directory path.

**Task:** Add explicit examples to the tool description:
- `NOT path:vendor` — exclude vendor directories
- `path:rfs-platform` — scope search to a subdirectory
- A combined example: `jwt middleware path:rfs-platform NOT path:vendor file:.go`

---

## 2. Glob Support in `file:` and `path:` Filters
**Priority: High**

Both `file:` and `path:` currently match on substring only. This causes two problems:
- `file:test` cannot distinguish `_test.go` from `IncidentPopupView.test.tsx`
- `path:rfs-resource` ambiguously matches both `rfs-resource` and `rfs-resource-events`

Without glob support there is no way to scope searches to a subtree, match filename suffixes
precisely, or target a family of related services cleanly.

**Task:** Support glob patterns in both the `file:` and `path:` operators:

File examples:
- `file:*_test.go` — match only Go test files
- `file:*.go` — match all Go files
- `file:*.mod` — match go.mod files

Path examples:
- `path:rfs-*/coverage` — all coverage packages across the rfs family of services
- `path:*/pkg/*` — only files following standard Go project layout
- `path:rfs-platform/pkg/services/**` — scope deep into a specific subtree
- `NOT path:*/vendor/*` — exclude vendor directories at any depth

If glob support is already implemented in the underlying engine for either operator, expose
it in the MCP tool description with examples as above. Ensure the tool description shows
the glob support.

---

## 3. Audit Full Query Syntax Against MCP Documentation
**Priority: High**

The `NOT path:vendor` gap suggests other supported operators may also be undocumented in the MCP
tool definition. An LLM will not use features it cannot see.

**Task:** Review the full list of supported query syntax in the underlying engine and ensure every
operator and filter is represented in the MCP tool description with at least one concrete example.
Specifically check whether the following are already supported but undocumented:
- `lang:go` or `ext:go` (language/extension filter using internal language detection)
- `complexity:>N` (minimum complexity threshold)
- `NEAR` or proximity operators

---

## 4. First-Class Language/Extension Filter
**Priority: Medium**

Using `file:.go` as a substring trick is fragile — it could match `django.go.tmpl` or similar.
CodeSpelunker already detects language internally (results show `"language":"Go"`) so the data
exists to power a proper filter.

**Task:** Implement and expose a `lang:` or `ext:` operator that uses the internal language
detection rather than substring filename matching. Examples:
- `lang:go` — only Go files
- `lang:typescript` — only TypeScript files
- `ext:mod` — files with `.mod` extension

---

## 5. Minimum Complexity Threshold Filter
**Priority: Medium**

The `gravity` setting boosts high-complexity files in ranking but does not hard-filter them.
Vendor files with high complexity can still outrank simpler project files. There is no way to
say "only show me files where cyclomatic complexity exceeds N."

**Task:** Implement a `complexity:` filter operator that acts as a hard floor:
- `complexity:>50` — only return files/results from files with cyclomatic complexity above 50
- `complexity:>100` — useful for finding genuinely complex business logic
- Should be combinable with other filters: `incident prediction complexity:>80 NOT path:vendor`

---

## 6. Result Deduplication for Near-Identical Files
**Priority: Medium**

In a monorepo-style directory where code is copy-evolved between projects, near-identical files
surface as separate high-scoring results. In testing, `rfs-resource/coverage/database_sort.go` and
`rfs-platform/pkg/coverage/store_sort.go` returned nearly identical content and scores, consuming
two result slots for effectively one finding.

**Task:** Implement a similarity threshold that collapses near-duplicate results:
- Show the highest-scoring result and note the existence of near-duplicates inline
- Make the deduplication threshold configurable or opt-in via a query flag (e.g. `dedup:true`)

---

## 7. Proximity / NEAR Operator
**Priority: Low**

Boolean `OR` chains of related terms match files where the terms appear in completely unrelated
contexts. There is no way to express "these terms appear near each other" which is essential for
finding functions that do a specific combination of things.

**Task:** Implement a `NEAR` proximity operator:
- `jwt NEAR validate NEAR handler` — terms must appear within N lines of each other
- Configurable distance, e.g. `NEAR/5` for within 5 lines
- Particularly useful for domain logic searches where you're searching by concept rather than
  exact symbol name
```

## 8. Expose Code/String/Comment Filter in MCP Tool Documentation
**Priority: High**

The underlying engine supports filtering results to only code, only strings, or only comments but
this is not documented in the MCP tool description and is therefore never used.

**Task:** Add the operator name and examples to the MCP tool description. Suggested examples to
cover the main use cases:
- Filter to strings only — useful for finding dependency names, config values, connection strings
- Filter to code only — reduces noise from comments that mention a term without implementing it
- Filter to comments only — useful for finding developer explanations of complex logic and
  orientation in an unfamiliar codebase

Once syntax is confirmed, add combined examples such as:
- `dense_rank <string-filter>` — find the actual SQL string rather than mentions in comments
- `middleware <code-filter> NOT path:vendor` — find middleware implementations not documentation
- `authentication <comment-filter> path:rfs-platform` — find where devs have explained auth flow