## Task: Implement "Intent-Based" Complexity Gravity in `cs`

### 1. Objective

Implement a "Complexity Gravity" ranker that boosts files based on their cyclomatic complexity. The implementation must include a mapping layer that allows users to set "Intents" (e.g., `brain`, `logic`, `low`) which adjust the gravity strength automatically.

### 2. The Multiplier Math

The base score should be modified using a logarithmic complexity boost. Copy the following formula for documentation:

**Formula:**
`Score_final = Score_base * (1 + (ln(1 + Complexity) * Strength))`

This should be applied in the existing `rankResultsStructural` ranker logic.

### 3. Argument Mapping (The "Intents")

The user/LLM should be able to pass a string or flag to set the `Strength`. Implement the following mapping:

| Intent | Strength | Purpose |
| --- | --- | --- |
| **`brain`** | `2.5` | Aggressively surface the most complex "core" logic. |
| **`logic`** | `1.5` | Standard boost to prioritize code over docs/data. |
| **`default`** | `1.0` | Balanced search. |
| **`low`** | `0.2` | Flatten gravity (good for finding simple boilerplate). |
| **`off`** | `0.0` | Pure text relevance (BM25 only). |

### 4. Implementation Requirements for the Agent

1. **Update Config:** Add a `GravityStrength float64` field to the ranking configuration.
2. **Add Intent Resolver:** Create a helper function that takes a string (from CLI or query parser) and sets the `GravityStrength` based on the table above.
3. **Refactor Ranker:** Update `rankResultsStructural` (or the ranking pipeline) to apply the multiplier:

```go
// Inside the ranking loop
// math.Log1p(x) is the implementation of ln(1+x)
boost := math.Log1p(float64(file.Complexity))
file.Score *= (1.0 + (boost * config.GravityStrength))
```


4. **CLI/Query Integration:** * Support a flag like `--logic=[brain|logic|low|off]`.
* Ensure the query parser can handle `logic:brain` syntax if available.


### 5. Why this is the "Smart" Way

* **Markdown/Prose:** Since they have `0` complexity, `math.Log1p(0)` returns `0`. The multiplier becomes `1.0 + (0 * Strength)`, which is exactly `1.0`. **Prose is never boosted, regardless of the intent.**
* **Signal separation:** By using `math.Log1p`, we ensure that a file with complexity 100 isn't 100x stronger than a file with complexity 1, but rather significantly stronger in a way that respects textual relevance.

