## Task: Implement Signal-to-Noise (Entropy) Penalty in `cs`

### 1. Objective

Implement a "Noise Penalty" that dampens the score of files with low information density. We define "Noise" as files that are massive in size but contain little to no logical complexity (e.g., minified JS, massive JSON blobs, SQL dumps, or logs).

### 2. The Multiplier Math

The penalty is calculated by comparing the logical complexity to the file size. High-complexity small files are "High Signal"; low-complexity large files are "Noise."

**Formula:**
`SignalRatio = (Complexity + 1) / log10(FileBytes)`
`Penalty = min(1.0, SignalRatio * Sensitivity)`


### 3. Intent Mapping (The "Noise Floor")

Implement the following mapping to allow users to control the suppression of data files:

| Intent | Sensitivity | Purpose |
| --- | --- | --- |
| **`silence`** | `0.1` | Extreme penalty. Effectively hides all non-code files. |
| **`quiet`** | `0.5` | Strong penalty for data files and massive boilerplate. |
| **`default`** | `1.0` | Balanced. Smoothly dampens scores for large JSON/Log files. |
| **`loud`** | `2.0` | Minimal penalty. Allows data files to compete with code. |
| **`raw`** | `100.0` | Penalty effectively disabled. |

### 4. Implementation Requirements for the Agent

1. **Update Config:** Add a `NoiseSensitivity float64` field.
2. **Logic Implementation:** * Ensure `FileBytes` is at least `10` to avoid `log10(1)` resulting in zero or negative values.
* The penalty must be **capped at 1.0**. This filter is strictly a "sink"; it should never boost a score.


3. **Refactor Ranker:**
```go
// Inside the rankResultsStructural ranking loop
// Ensure we don't divide by zero or get negative logs
safeBytes := math.Max(10, float64(file.Bytes))
fileSizeLog := math.Log10(safeBytes)

// Signal is complexity relative to magnitude of file size
signalRatio := (float64(file.Complexity) + 1.0) / fileSizeLog

// Apply sensitivity and clamp
penalty := math.Min(1.0, signalRatio * config.NoiseSensitivity)

file.Score *= penalty

```


4. **CLI/Query Integration:**
* Support a flag like `--noise=[silence|quiet|default|loud|raw]`.
* Ensure the query parser can resolve these strings to the sensitivity values.



### 5. Why this is the "Killer" feature

Most search tools treat a 1MB JSON file and a 10KB Go file as equally "searchable." By implementing this:

* **JSON/Logs/Lockfiles:** Will see their scores slashed by 70–90% because their `Complexity + 1` is usually `1`, while their `log10(Bytes)` is `5` or `6`.
* **Clean Logic:** A 5KB file with a complexity of 20 will have a `SignalRatio` of `21 / 3.7 ≈ 5.6`. Since we cap at `1.0`, its score remains **untouched**.

---

### Verification

* **Noise Suppression:** Search for a common key like `id`. A JSON data export should no longer be the #1 result if there is a struct definition or a database handler elsewhere in the repo.
* **Sensitivity Check:** Switching to `noise:silence` should almost entirely remove `.json` and `.map` files from the top of the results list.
